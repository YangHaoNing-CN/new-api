/*
Copyright (C) 2025 QuantumNous

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

For commercial licensing, please contact support@quantumnous.com
*/

import React from 'react';
import { Card, Avatar, Typography, Table, Tag } from '@douyinfe/semi-ui';
import { IconCoinMoneyStroked } from '@douyinfe/semi-icons';
import { calculateModelPrice } from '../../../../../helpers';

const { Text } = Typography;

const ModelPricingTable = ({
  modelData,
  groupRatio,
  currency,
  tokenUnit,
  displayPrice,
  showRatio,
  usableGroup,
  autoGroups = [],
  t,
}) => {
  const modelEnableGroups = Array.isArray(modelData?.enable_groups)
    ? modelData.enable_groups
    : [];
  const autoChain = autoGroups.filter((g) => modelEnableGroups.includes(g));
  const renderGroupPriceTable = () => {
    // 仅展示模型可用的分组：模型 enable_groups 与用户可用分组的交集

    const availableGroups = Object.keys(usableGroup || {})
      .filter((g) => g !== '')
      .filter((g) => g !== 'auto')
      .filter((g) => modelEnableGroups.includes(g));

    // 准备表格数据
    const tableData = availableGroups.map((group) => {
      const priceData = modelData
        ? calculateModelPrice({
            record: modelData,
            selectedGroup: group,
            groupRatio,
            tokenUnit,
            displayPrice,
            currency,
          })
        : { inputPrice: '-', outputPrice: '-', price: '-' };

      // 获取分组倍率
      const groupRatioValue =
        groupRatio && groupRatio[group] ? groupRatio[group] : 1;

      const hasTiered =
        modelData?.tiered_pricing && modelData.tiered_pricing.length > 0;

      return {
        key: group,
        group: group,
        ratio: groupRatioValue,
        billingType:
          modelData?.quota_type === 0
            ? hasTiered
              ? t('阶梯计价')
              : t('按量计费')
            : modelData?.quota_type === 1
              ? t('按次计费')
              : '-',
        inputPrice:
          modelData?.quota_type === 0
            ? hasTiered
              ? priceData.inputPrice + t('起')
              : priceData.inputPrice
            : '-',
        outputPrice:
          modelData?.quota_type === 0
            ? hasTiered
              ? (priceData.completionPrice || priceData.outputPrice) + t('起')
              : priceData.completionPrice || priceData.outputPrice
            : '-',
        fixedPrice: modelData?.quota_type === 1 ? priceData.price : '-',
      };
    });

    // 定义表格列
    const columns = [
      {
        title: t('分组'),
        dataIndex: 'group',
        render: (text) => (
          <Tag color='white' size='small' shape='circle'>
            {text}
            {t('分组')}
          </Tag>
        ),
      },
    ];

    // 如果显示倍率，添加倍率列
    if (showRatio) {
      columns.push({
        title: t('倍率'),
        dataIndex: 'ratio',
        render: (text) => (
          <Tag color='white' size='small' shape='circle'>
            {text}x
          </Tag>
        ),
      });
    }

    // 添加计费类型列
    columns.push({
      title: t('计费类型'),
      dataIndex: 'billingType',
      render: (text) => {
        let color = 'white';
        if (text === t('按量计费')) color = 'violet';
        else if (text === t('按次计费')) color = 'teal';
        return (
          <Tag color={color} size='small' shape='circle'>
            {text || '-'}
          </Tag>
        );
      },
    });

    // 根据计费类型添加价格列
    if (modelData?.quota_type === 0) {
      // 按量计费
      columns.push(
        {
          title: t('提示'),
          dataIndex: 'inputPrice',
          render: (text) => (
            <>
              <div className='font-semibold text-orange-600'>{text}</div>
              <div className='text-xs text-gray-500'>
                / {tokenUnit === 'K' ? '1K' : '1M'} tokens
              </div>
            </>
          ),
        },
        {
          title: t('补全'),
          dataIndex: 'outputPrice',
          render: (text) => (
            <>
              <div className='font-semibold text-orange-600'>{text}</div>
              <div className='text-xs text-gray-500'>
                / {tokenUnit === 'K' ? '1K' : '1M'} tokens
              </div>
            </>
          ),
        },
      );
    } else {
      // 按次计费
      columns.push({
        title: t('价格'),
        dataIndex: 'fixedPrice',
        render: (text) => (
          <>
            <div className='font-semibold text-orange-600'>{text}</div>
            <div className='text-xs text-gray-500'>/ 次</div>
          </>
        ),
      });
    }

    return (
      <Table
        dataSource={tableData}
        columns={columns}
        pagination={false}
        size='small'
        bordered={false}
        className='!rounded-lg'
      />
    );
  };

  const formatTokens = (tokens) => {
    if (tokens === 0) return '∞';
    if (tokens >= 1000000) return `${tokens / 1000000}M`;
    if (tokens >= 1000) return `${tokens / 1000}K`;
    return `${tokens}`;
  };

  const renderTieredPricingTable = () => {
    if (
      !modelData?.tiered_pricing ||
      modelData.tiered_pricing.length === 0
    )
      return null;

    const availableGroups = Object.keys(usableGroup || {})
      .filter((g) => g !== '' && g !== 'auto')
      .filter((g) => modelEnableGroups.includes(g));

    const unitDivisor = tokenUnit === 'K' ? 1000 : 1;
    let symbol = '$';
    if (currency === 'CNY') symbol = '¥';
    else if (currency === 'CUSTOM') {
      try {
        const s = JSON.parse(localStorage.getItem('status') || '{}');
        symbol = s?.custom_currency_symbol || '¤';
      } catch {
        symbol = '¤';
      }
    }

    // 构建 分组×阶梯 交叉数据
    const tieredData = [];
    availableGroups.forEach((group) => {
      const grpRatio =
        groupRatio && groupRatio[group] ? groupRatio[group] : 1;
      modelData.tiered_pricing.forEach((tier, idx) => {
        const prevMax =
          idx > 0 ? modelData.tiered_pricing[idx - 1].max_tokens : 0;
        const tierInputUSD = tier.input_ratio * 2 * grpRatio;
        const tierOutputUSD =
          tier.input_ratio * tier.completion_ratio * 2 * grpRatio;
        const numIn =
          parseFloat(
            displayPrice(tierInputUSD).toString().replace(/[^0-9.]/g, ''),
          ) / unitDivisor;
        const numOut =
          parseFloat(
            displayPrice(tierOutputUSD).toString().replace(/[^0-9.]/g, ''),
          ) / unitDivisor;

        tieredData.push({
          key: `${group}-${idx}`,
          group,
          ratio: grpRatio,
          range:
            tier.max_tokens === 0
              ? `>${formatTokens(prevMax)}`
              : `${formatTokens(prevMax)}~${formatTokens(tier.max_tokens)}`,
          inputPrice: `${symbol}${numIn.toFixed(4)}`,
          outputPrice: `${symbol}${numOut.toFixed(4)}`,
        });
      });
    });

    const tieredColumns = [
      {
        title: t('分组'),
        dataIndex: 'group',
        render: (text) => (
          <Tag color='white' size='small' shape='circle'>
            {text}
            {t('分组')}
          </Tag>
        ),
      },
      {
        title: t('Token范围'),
        dataIndex: 'range',
        render: (text) => (
          <Tag color='white' size='small' shape='circle'>
            {text}
          </Tag>
        ),
      },
      {
        title: t('提示'),
        dataIndex: 'inputPrice',
        render: (text) => (
          <>
            <div className='font-semibold text-orange-600'>{text}</div>
            <div className='text-xs text-gray-500'>
              / {tokenUnit === 'K' ? '1K' : '1M'} tokens
            </div>
          </>
        ),
      },
      {
        title: t('补全'),
        dataIndex: 'outputPrice',
        render: (text) => (
          <>
            <div className='font-semibold text-orange-600'>{text}</div>
            <div className='text-xs text-gray-500'>
              / {tokenUnit === 'K' ? '1K' : '1M'} tokens
            </div>
          </>
        ),
      },
    ];

    if (showRatio) {
      tieredColumns.splice(1, 0, {
        title: t('倍率'),
        dataIndex: 'ratio',
        render: (text) => (
          <Tag color='white' size='small' shape='circle'>
            {text}x
          </Tag>
        ),
      });
    }

    return (
      <div className='mb-4'>
        <div className='flex items-center mb-2'>
          <Tag color='orange' size='small'>
            {t('阶梯计价')}
          </Tag>
          <span className='text-xs text-gray-500 ml-2'>
            {t('价格随输入Token数量分段变化')}
          </span>
        </div>
        <Table
          dataSource={tieredData}
          columns={tieredColumns}
          pagination={false}
          size='small'
          bordered={false}
          className='!rounded-lg'
        />
      </div>
    );
  };

  return (
    <Card className='!rounded-2xl shadow-sm border-0'>
      <div className='flex items-center mb-4'>
        <Avatar size='small' color='orange' className='mr-2 shadow-md'>
          <IconCoinMoneyStroked size={16} />
        </Avatar>
        <div>
          <Text className='text-lg font-medium'>{t('分组价格')}</Text>
          <div className='text-xs text-gray-600'>
            {t('不同用户分组的价格信息')}
          </div>
        </div>
      </div>
      {autoChain.length > 0 && (
        <div className='flex flex-wrap items-center gap-1 mb-4'>
          <span className='text-sm text-gray-600'>{t('auto分组调用链路')}</span>
          <span className='text-sm'>→</span>
          {autoChain.map((g, idx) => (
            <React.Fragment key={g}>
              <Tag color='white' size='small' shape='circle'>
                {g}
                {t('分组')}
              </Tag>
              {idx < autoChain.length - 1 && <span className='text-sm'>→</span>}
            </React.Fragment>
          ))}
        </div>
      )}
      {renderTieredPricingTable()}
      {renderGroupPriceTable()}
    </Card>
  );
};

export default ModelPricingTable;
